# -*- coding: utf-8 -*-
"""Arrays Lineares.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pj6vJg3NQkfedNshaqohR_lb3iGqDJ5U

Dúvidas:
- Quando formos apresentar as métricas de ordenação e busca, devemos considera-las separadas por operação? Ou deve ser a soma de todas as operações?
"""

import numpy as np
import time
import random

# INSERT ALGORITHMS

#def insert_value(value):


# SEARCH ALGORITHMS

def sequential_search(arr, target):
    steps = 0
    for i, value in enumerate(arr):
        steps += 1
        if value == target:
            return i, steps
    return -1, steps

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    steps = 0
    while left <= right:
        steps += 1
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid, steps
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1, steps


# SORTING ALGORITHMS

def bubble_sort(arr):
    n = len(arr)
    swap_count = 0
    shift_count = 0
    step_count = 0
    for i in range(n):
        swapped = False
        for j in range(n - i - 1):  # A cada rodada do Bubblue sort os maiores elementos vão sendo movidos para o final da lista e não precisam mais ser verificados.
            step_count += 1         # Número de operações
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swap_count += 1     # Número de troca de elementos
                swapped = True
        if not swapped:
            break
    return arr, swap_count, shift_count, step_count

def selection_sort(arr):
  n = len(arr)
  swap_count = 0
  shift_count = 0
  step_count = 0
  for i in range(n):
    min_idx = i
    for j in range(i + 1, n):     # Loop para descobrir o índice do menor elemento da lista
        step_count += 1
        if arr[j] < arr[min_idx]:
            min_idx = j
    if min_idx != i:
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        swap_count += 1
  return arr, swap_count, shift_count, step_count

def insertion_sort(arr):
  n = len(arr)
  swap_count = 0
  shift_count = 0
  step_count = 0
  for i in range(1, n):
      key = arr[i]
      j = i - 1
      while j >= 0:
          step_count += 1
          if arr[j] > key:
              arr[j + 1] = arr[j]  # Desloca uma posição
              shift_count += 1
              j -= 1
          else:
              break
      arr[j + 1] = key
  return arr, swap_count, shift_count, step_count

# Teste com Bubble Sort
arr = [3, 2, 8, 1, 5]

start_time = time.time()
sorted_arr, swaps, _, steps_to_sort = bubble_sort(arr)
_, steps_to_find = binary_search(sorted_arr, 2)
end_time = time.time()

print(f"Array ordenado: {sorted_arr}")
print(f"Número de steps para ordenar: {steps_to_sort}")
print(f"Número de swaps para ordenar: {swaps}")
print(f"Número de steps para buscar: {steps_to_find}")
print(f"Tempo de execução: {end_time - start_time:.6f} segundos")

# Teste com Selection Sort
arr = [3, 2, 8, 1, 5]

start_time = time.time()
sorted_arr, swaps, _, steps_to_sort = selection_sort(arr)
_, steps_to_find = binary_search(arr, 2)
end_time = time.time()

print(f"Array ordenado: {sorted_arr}")
print(f"Número de steps para ordenar: {steps_to_sort}")
print(f"Número de swaps para ordenar: {swaps}")
print(f"Número de steps para buscar: {steps_to_find}")
print(f"Tempo de execução: {end_time - start_time:.6f} segundos")

# Teste com Insertion Sort
arr = [3, 2, 8, 1, 5]

start_time = time.time()
sorted_arr, shifts, _, steps_to_sort = insertion_sort(arr)
_, steps_to_find = binary_search(arr, 2)
end_time = time.time()

print(f"Array ordenado: {sorted_arr}")
print(f"Número de steps para ordenar: {steps_to_sort}")
print(f"Número de shifts para ordenar: {shifts}")
print(f"Número de steps para buscar: {steps_to_find}")
print(f"Tempo de execução: {end_time - start_time:.6f} segundos")

sizes = [100, 200, 300, 400, 500]
algorithms = [
    ('Bubble Sort', bubble_sort),
    ('Insertion Sort', insertion_sort),
    ('Selection Sort', selection_sort)
]

results = {
    "times": {name: [] for name, _ in algorithms},
    "steps": {name: [] for name, _ in algorithms},
    "swaps": {name: [] for name, _ in algorithms},
    "shifts": {name: [] for name, _ in algorithms},
    "mem_moves": {name: [] for name, _ in algorithms}
}

base_arrays = {size: np.random.randint(0, 10000, size) for size in sizes}

print(f"ORDENAÇÃO")

for name, func in algorithms:
    print(f"\n{name}:")
    for size in sizes:
        arr_copy = base_arrays[size].copy()
        start = time.time()
        _, swap_count, shift_count, step_count = func(arr_copy)
        end = time.time()

        results["times"][name].append(end - start)
        results["steps"][name].append(step_count)
        results["swaps"][name].append(swap_count)
        results["shifts"][name].append(shift_count)

        #Shift == 1 memory move | Swap == 2 memory moves
        results["mem_moves"][name].append(swap_count * 2 + shift_count)

        print(
            f"Size {size:6d} | Swaps: {swap_count:6d} | Shifts: {shift_count:6d} "
            f"| Steps: {step_count:6d} | MemMoves: {swap_count * 2 + shift_count:3d} "
            f"| Time: {end - start:.4f} s "
            f"| {base_arrays[size][:5]} -> {arr_copy[:5]}"
        )